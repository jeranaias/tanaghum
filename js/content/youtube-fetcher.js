/**
 * Tanaghum YouTube Fetcher
 * Fetches video metadata and captions via Cloudflare Worker
 */

import { Config } from '../core/config.js';
import { EventBus, Events } from '../core/event-bus.js';
import { StateManager } from '../core/state-manager.js';
import { extractYouTubeId, createLogger } from '../core/utils.js';

const log = createLogger('YouTube');

/**
 * YouTube Fetcher class
 */
class YouTubeFetcher {
  constructor() {
    this.workerUrl = Config.WORKER_URL;
    this.cache = new Map();
  }

  /**
   * Validate and extract video ID from URL
   * @param {string} url - YouTube URL
   * @returns {string|null} Video ID or null
   */
  extractVideoId(url) {
    return extractYouTubeId(url);
  }

  /**
   * Fetch video metadata
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<Object>} Video metadata
   */
  async getMetadata(urlOrId) {
    const videoId = this.extractVideoId(urlOrId) || urlOrId;

    if (!videoId || !/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
      throw new Error('Invalid YouTube video ID');
    }

    // Check cache
    const cacheKey = `meta:${videoId}`;
    if (this.cache.has(cacheKey)) {
      log.debug('Using cached metadata for', videoId);
      return this.cache.get(cacheKey);
    }

    log.log('Fetching metadata for', videoId);

    const response = await fetch(
      `${this.workerUrl}/api/youtube/metadata?v=${videoId}`
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || `Failed to fetch metadata: ${response.status}`);
    }

    const data = await response.json();

    if (data.error) {
      throw new Error(data.error);
    }

    // Cache result
    this.cache.set(cacheKey, data);

    // Update state
    StateManager.set('source', {
      type: 'youtube',
      url: `https://www.youtube.com/watch?v=${videoId}`,
      videoId
    });

    EventBus.emit(Events.CONTENT_LOADED, {
      type: 'youtube',
      metadata: data
    });

    return data;
  }

  /**
   * Fetch video captions - tries client-side first, then worker fallback with retries
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<Object>} Captions data
   */
  async getCaptions(urlOrId) {
    const videoId = this.extractVideoId(urlOrId) || urlOrId;

    if (!videoId || !/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
      throw new Error('Invalid YouTube video ID');
    }

    // Check cache
    const cacheKey = `captions:${videoId}`;
    if (this.cache.has(cacheKey)) {
      log.debug('Using cached captions for', videoId);
      return this.cache.get(cacheKey);
    }

    log.log('Fetching captions for', videoId);

    // Method 1: Try client-side fetch (browser can access YouTube directly)
    try {
      const clientData = await this.fetchCaptionsClientSide(videoId);
      if (clientData && clientData.available) {
        log.log('Got captions via client-side fetch');
        this.cache.set(cacheKey, clientData);
        this.updateStateWithCaptions(clientData);
        return clientData;
      }
    } catch (e) {
      log.warn('Client-side caption fetch failed:', e.message);
    }

    // Method 2: Fall back to worker with retries (worker results can be intermittent)
    log.log('Falling back to worker for captions');

    const maxRetries = 3;
    let lastError = null;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(
          `${this.workerUrl}/api/youtube/captions?v=${videoId}`
        );

        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          lastError = error.error || `Failed to fetch captions: ${response.status}`;
          continue;
        }

        const data = await response.json();

        if (data.available && data.segments && data.segments.length > 0) {
          log.log(`Got captions from worker on attempt ${attempt}`);
          // Cache result
          this.cache.set(cacheKey, data);
          this.updateStateWithCaptions(data);
          return data;
        }

        lastError = data.error || 'No captions available';
        log.warn(`Worker attempt ${attempt} returned no captions: ${lastError}`);

        // Small delay before retry
        if (attempt < maxRetries) {
          await new Promise(r => setTimeout(r, 500));
        }
      } catch (e) {
        lastError = e.message;
        log.warn(`Worker attempt ${attempt} failed: ${e.message}`);
      }
    }

    throw new Error(lastError || 'No captions available for this video');
  }

  /**
   * Update state with caption data
   */
  updateStateWithCaptions(data) {
    StateManager.set('transcript', {
      text: data.fullText,
      segments: data.segments,
      vtt: data.vtt,
      language: data.language,
      confidence: data.isAutoGenerated ? 0.7 : 0.95
    });

    EventBus.emit(Events.TRANSCRIPTION_COMPLETE, {
      source: 'youtube',
      transcript: data.fullText,
      segments: data.segments
    });
  }

  /**
   * Fetch captions directly from browser (not blocked by YouTube)
   */
  async fetchCaptionsClientSide(videoId) {
    // Fetch the watch page to extract caption tracks
    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const response = await fetch(watchUrl, {
      credentials: 'omit' // Don't send cookies
    });

    if (!response.ok) {
      throw new Error('Failed to fetch video page');
    }

    const html = await response.text();

    // Extract caption tracks from ytInitialPlayerResponse
    let captionTracks = null;

    // Method 1: Direct captionTracks extraction
    const captionTracksMatch = html.match(/"captionTracks":\s*(\[[\s\S]*?\])(?=,")/);
    if (captionTracksMatch) {
      try {
        captionTracks = JSON.parse(captionTracksMatch[1]);
      } catch (e) {
        log.warn('Failed to parse captionTracks:', e.message);
      }
    }

    // Method 2: Extract from ytInitialPlayerResponse
    if (!captionTracks) {
      const playerResponseMatch = html.match(/var\s+ytInitialPlayerResponse\s*=\s*(\{[\s\S]*?\});/);
      if (playerResponseMatch) {
        try {
          const playerResponse = JSON.parse(playerResponseMatch[1]);
          captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
        } catch (e) {
          log.warn('Failed to parse player response:', e.message);
        }
      }
    }

    if (!captionTracks || captionTracks.length === 0) {
      return { available: false, error: 'No captions found' };
    }

    // Find best track (prefer Arabic, then auto-generated, then first)
    let track = captionTracks.find(t => t.languageCode === 'ar');
    if (!track) track = captionTracks.find(t => t.languageCode?.startsWith('ar'));
    if (!track) track = captionTracks.find(t => t.kind === 'asr');
    if (!track) track = captionTracks[0];

    if (!track?.baseUrl) {
      return { available: false, error: 'No valid caption track' };
    }

    // Fetch caption content in JSON format
    const captionUrl = new URL(track.baseUrl);
    captionUrl.searchParams.set('fmt', 'json3');

    const captionResponse = await fetch(captionUrl.toString());
    if (!captionResponse.ok) {
      throw new Error('Failed to fetch caption content');
    }

    const captionData = await captionResponse.json();
    const events = captionData.events || [];

    // Parse events into segments
    const segments = events
      .filter(e => e.segs && e.tStartMs !== undefined)
      .map(event => {
        const text = event.segs
          .map(seg => seg.utf8 || '')
          .join('')
          .replace(/\n/g, ' ')
          .trim();

        return {
          start: event.tStartMs / 1000,
          duration: (event.dDurationMs || 2000) / 1000,
          text,
          confidence: 0.75 // YouTube auto-captions are reasonably accurate
        };
      })
      .filter(seg => seg.text.length > 0);

    if (segments.length === 0) {
      return { available: false, error: 'Failed to parse captions' };
    }

    const fullText = segments.map(s => s.text).join(' ');

    return {
      videoId,
      available: true,
      language: track.languageCode,
      languageName: track.name?.simpleText || track.name?.runs?.[0]?.text || track.languageCode,
      isAutoGenerated: track.kind === 'asr',
      trackCount: captionTracks.length,
      availableLanguages: captionTracks.map(t => ({
        code: t.languageCode,
        name: t.name?.simpleText || t.name?.runs?.[0]?.text || t.languageCode
      })),
      segments,
      fullText,
      wordCount: fullText.split(/\s+/).filter(w => w.length > 0).length,
      source: 'client-side'
    };
  }

  /**
   * Extract audio URL directly from browser (bypasses server IP blocking)
   * This works because the request comes from the user's browser, not a server
   * @param {string} videoId - YouTube video ID
   * @returns {Promise<Object>} Audio extraction result
   */
  async extractAudioClientSide(videoId) {
    log.log('Attempting client-side audio extraction for', videoId);

    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const response = await fetch(watchUrl, {
      credentials: 'omit'
    });

    if (!response.ok) {
      throw new Error('Failed to fetch video page');
    }

    const html = await response.text();

    // Extract ytInitialPlayerResponse
    let playerResponse = null;

    // Try multiple extraction patterns
    const patterns = [
      /var\s+ytInitialPlayerResponse\s*=\s*(\{[\s\S]*?\});/,
      /ytInitialPlayerResponse\s*=\s*(\{[\s\S]*?\});/,
      /"streamingData":\s*(\{[\s\S]*?"adaptiveFormats"[\s\S]*?\})\s*,\s*"[a-zA-Z]/
    ];

    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match) {
        try {
          // For the streamingData pattern, wrap it properly
          if (pattern.source.includes('streamingData')) {
            playerResponse = { streamingData: JSON.parse(match[1]) };
          } else {
            playerResponse = JSON.parse(match[1]);
          }
          break;
        } catch (e) {
          log.warn('Failed to parse with pattern:', e.message);
        }
      }
    }

    if (!playerResponse) {
      return { available: false, error: 'Could not extract player response' };
    }

    // Check for playability
    const playabilityStatus = playerResponse.playabilityStatus?.status;
    if (playabilityStatus === 'LOGIN_REQUIRED' || playabilityStatus === 'ERROR') {
      return {
        available: false,
        error: playerResponse.playabilityStatus?.reason || 'Video not available',
        blocked: true
      };
    }

    // Extract audio formats from streamingData
    const streamingData = playerResponse.streamingData;
    if (!streamingData) {
      return { available: false, error: 'No streaming data available' };
    }

    // Get adaptive formats (separate audio/video streams)
    const adaptiveFormats = streamingData.adaptiveFormats || [];

    // Filter for audio-only formats
    const audioFormats = adaptiveFormats.filter(f =>
      f.mimeType && f.mimeType.startsWith('audio/') && f.url
    );

    if (audioFormats.length === 0) {
      // Try formats array as fallback (combined streams)
      const formats = streamingData.formats || [];
      const fallbackFormats = formats.filter(f => f.url);

      if (fallbackFormats.length > 0) {
        // Use the lowest quality (audio-focused)
        const best = fallbackFormats[fallbackFormats.length - 1];
        return {
          videoId,
          available: true,
          audioUrl: best.url,
          mimeType: best.mimeType || 'audio/mp4',
          quality: 'combined',
          source: 'client-side-combined'
        };
      }

      return { available: false, error: 'No audio formats available' };
    }

    // Sort by audio quality (bitrate)
    audioFormats.sort((a, b) => (b.bitrate || 0) - (a.bitrate || 0));
    const bestAudio = audioFormats[0];

    log.log('Found audio format:', bestAudio.mimeType, bestAudio.bitrate, 'bps');

    return {
      videoId,
      available: true,
      audioUrl: bestAudio.url,
      mimeType: bestAudio.mimeType,
      bitrate: bestAudio.bitrate,
      contentLength: bestAudio.contentLength,
      duration: playerResponse.videoDetails?.lengthSeconds,
      title: playerResponse.videoDetails?.title,
      source: 'client-side'
    };
  }

  /**
   * Fetch both metadata and captions
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<Object>} Combined data
   */
  async fetchVideo(urlOrId) {
    const videoId = this.extractVideoId(urlOrId) || urlOrId;

    log.log('Fetching complete video data for', videoId);

    // Fetch both in parallel
    const [metadata, captions] = await Promise.all([
      this.getMetadata(videoId),
      this.getCaptions(videoId).catch(err => {
        log.warn('Captions not available:', err.message);
        return { available: false, error: err.message };
      })
    ]);

    return {
      videoId,
      metadata,
      captions,
      hasCaptions: captions.available,
      needsTranscription: !captions.available
    };
  }

  /**
   * Get YouTube thumbnail URL
   * @param {string} videoId - Video ID
   * @param {string} quality - Thumbnail quality
   * @returns {string} Thumbnail URL
   */
  getThumbnailUrl(videoId, quality = 'hqdefault') {
    const qualities = {
      default: 'default',
      medium: 'mqdefault',
      high: 'hqdefault',
      standard: 'sddefault',
      maxres: 'maxresdefault'
    };

    const q = qualities[quality] || quality;
    return `https://i.ytimg.com/vi/${videoId}/${q}.jpg`;
  }

  /**
   * Get embed URL for iframe
   * @param {string} videoId - Video ID
   * @param {Object} options - Embed options
   * @returns {string} Embed URL
   */
  getEmbedUrl(videoId, options = {}) {
    const {
      autoplay = false,
      controls = true,
      start = 0
    } = options;

    const params = new URLSearchParams({
      autoplay: autoplay ? '1' : '0',
      controls: controls ? '1' : '0',
      start: String(Math.floor(start))
    });

    return `https://www.youtube.com/embed/${videoId}?${params}`;
  }

  /**
   * Check if a video has Arabic captions
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<boolean>}
   */
  async hasArabicCaptions(urlOrId) {
    try {
      const metadata = await this.getMetadata(urlOrId);
      return metadata.captions?.available || false;
    } catch {
      return false;
    }
  }

  /**
   * Clear cache
   * @param {string} [videoId] - Optional specific video to clear
   */
  clearCache(videoId) {
    if (videoId) {
      this.cache.delete(`meta:${videoId}`);
      this.cache.delete(`captions:${videoId}`);
    } else {
      this.cache.clear();
    }
  }
}

// Singleton instance
const youtubeFetcher = new YouTubeFetcher();

export { youtubeFetcher, YouTubeFetcher };
