/**
 * Tanaghum YouTube Fetcher
 * Fetches video metadata and captions via Cloudflare Worker
 */

import { Config } from '../core/config.js';
import { EventBus, Events } from '../core/event-bus.js';
import { StateManager } from '../core/state-manager.js';
import { extractYouTubeId, createLogger } from '../core/utils.js';

const log = createLogger('YouTube');

/**
 * YouTube Fetcher class
 */
class YouTubeFetcher {
  constructor() {
    this.workerUrl = Config.WORKER_URL;
    this.cache = new Map();
  }

  /**
   * Validate and extract video ID from URL
   * @param {string} url - YouTube URL
   * @returns {string|null} Video ID or null
   */
  extractVideoId(url) {
    return extractYouTubeId(url);
  }

  /**
   * Fetch video metadata
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<Object>} Video metadata
   */
  async getMetadata(urlOrId) {
    const videoId = this.extractVideoId(urlOrId) || urlOrId;

    if (!videoId || !/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
      throw new Error('Invalid YouTube video ID');
    }

    // Check cache
    const cacheKey = `meta:${videoId}`;
    if (this.cache.has(cacheKey)) {
      log.debug('Using cached metadata for', videoId);
      return this.cache.get(cacheKey);
    }

    log.log('Fetching metadata for', videoId);

    const response = await fetch(
      `${this.workerUrl}/api/youtube/metadata?v=${videoId}`
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || `Failed to fetch metadata: ${response.status}`);
    }

    const data = await response.json();

    if (data.error) {
      throw new Error(data.error);
    }

    // Cache result
    this.cache.set(cacheKey, data);

    // Update state
    StateManager.set('source', {
      type: 'youtube',
      url: `https://www.youtube.com/watch?v=${videoId}`,
      videoId
    });

    EventBus.emit(Events.CONTENT_LOADED, {
      type: 'youtube',
      metadata: data
    });

    return data;
  }

  /**
   * Fetch video captions
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<Object>} Captions data
   */
  async getCaptions(urlOrId) {
    const videoId = this.extractVideoId(urlOrId) || urlOrId;

    if (!videoId || !/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
      throw new Error('Invalid YouTube video ID');
    }

    // Check cache
    const cacheKey = `captions:${videoId}`;
    if (this.cache.has(cacheKey)) {
      log.debug('Using cached captions for', videoId);
      return this.cache.get(cacheKey);
    }

    log.log('Fetching captions for', videoId);

    const response = await fetch(
      `${this.workerUrl}/api/youtube/captions?v=${videoId}`
    );

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || `Failed to fetch captions: ${response.status}`);
    }

    const data = await response.json();

    if (!data.available) {
      throw new Error(data.error || 'No captions available for this video');
    }

    // Cache result
    this.cache.set(cacheKey, data);

    // Update state with transcript
    StateManager.set('transcript', {
      text: data.fullText,
      segments: data.segments,
      vtt: data.vtt,
      language: data.language,
      confidence: data.isAutoGenerated ? 0.7 : 0.95
    });

    EventBus.emit(Events.TRANSCRIPTION_COMPLETE, {
      source: 'youtube',
      transcript: data.fullText,
      segments: data.segments
    });

    return data;
  }

  /**
   * Fetch both metadata and captions
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<Object>} Combined data
   */
  async fetchVideo(urlOrId) {
    const videoId = this.extractVideoId(urlOrId) || urlOrId;

    log.log('Fetching complete video data for', videoId);

    // Fetch both in parallel
    const [metadata, captions] = await Promise.all([
      this.getMetadata(videoId),
      this.getCaptions(videoId).catch(err => {
        log.warn('Captions not available:', err.message);
        return { available: false, error: err.message };
      })
    ]);

    return {
      videoId,
      metadata,
      captions,
      hasCaptions: captions.available,
      needsTranscription: !captions.available
    };
  }

  /**
   * Get YouTube thumbnail URL
   * @param {string} videoId - Video ID
   * @param {string} quality - Thumbnail quality
   * @returns {string} Thumbnail URL
   */
  getThumbnailUrl(videoId, quality = 'hqdefault') {
    const qualities = {
      default: 'default',
      medium: 'mqdefault',
      high: 'hqdefault',
      standard: 'sddefault',
      maxres: 'maxresdefault'
    };

    const q = qualities[quality] || quality;
    return `https://i.ytimg.com/vi/${videoId}/${q}.jpg`;
  }

  /**
   * Get embed URL for iframe
   * @param {string} videoId - Video ID
   * @param {Object} options - Embed options
   * @returns {string} Embed URL
   */
  getEmbedUrl(videoId, options = {}) {
    const {
      autoplay = false,
      controls = true,
      start = 0
    } = options;

    const params = new URLSearchParams({
      autoplay: autoplay ? '1' : '0',
      controls: controls ? '1' : '0',
      start: String(Math.floor(start))
    });

    return `https://www.youtube.com/embed/${videoId}?${params}`;
  }

  /**
   * Check if a video has Arabic captions
   * @param {string} urlOrId - YouTube URL or video ID
   * @returns {Promise<boolean>}
   */
  async hasArabicCaptions(urlOrId) {
    try {
      const metadata = await this.getMetadata(urlOrId);
      return metadata.captions?.available || false;
    } catch {
      return false;
    }
  }

  /**
   * Clear cache
   * @param {string} [videoId] - Optional specific video to clear
   */
  clearCache(videoId) {
    if (videoId) {
      this.cache.delete(`meta:${videoId}`);
      this.cache.delete(`captions:${videoId}`);
    } else {
      this.cache.clear();
    }
  }
}

// Singleton instance
const youtubeFetcher = new YouTubeFetcher();

export { youtubeFetcher, YouTubeFetcher };
